"""Layer 9: Computational Drug Validation — formal Rocq proof gate.

Replaces the hard-coded coqc template in run_pipeline.py.
Each molecule is validated across four dimensions:
  1. Lipinski RO5   (MW, LogP, HBD, HBA)
  2. Veber rules    (RotBonds, PSA)
  3. Safety         (RDKit PAINS + Brenk pre-filter)
  4. Formal proof   (coqc-verified Rocq lemma via LLM)

Confidence = fraction of the four checks that passed (0.0 – 1.0).
Feeds into Layer 20 (Evidence & Confidence Manager).
"""

from dataclasses import dataclass
from typing import Optional

from rdkit import Chem
from rdkit.Chem import Descriptors, rdMolDescriptors
from rdkit.Chem.FilterCatalog import FilterCatalog, FilterCatalogParams

from .proof_generator import ProofResult, RocqProofGenerator
from .rocq_verifier import RocqVerifier


# ---------------------------------------------------------------------------
# Result dataclass
# ---------------------------------------------------------------------------

@dataclass
class ValidationResult:
    smiles: str
    valid: bool           # True only if proof verified AND lipinski_ok AND safety_ok
    lipinski_ok: bool
    veber_ok: bool
    safety_ok: bool       # PAINS + Brenk clean
    proof_verified: bool
    proof: str
    confidence: float     # 0.0 – 1.0
    error_type: Optional[str]
    attempts: int


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _compute_descriptors(mol) -> dict:
    logP = Descriptors.MolLogP(mol)
    return {
        "MW":            round(Descriptors.ExactMolWt(mol), 4),
        "LogP":          round(logP, 4),
        "HBD":           rdMolDescriptors.CalcNumHBD(mol),
        "HBA":           rdMolDescriptors.CalcNumHBA(mol),
        "RotBonds":      rdMolDescriptors.CalcNumRotatableBonds(mol),
        "PSA":           round(Descriptors.TPSA(mol), 4),
        "MolRefract":    round(Descriptors.MolMR(mol), 4),
        "LogS":          round(-logP * 0.54 - 0.54, 4),
        "Rings":         rdMolDescriptors.CalcNumRings(mol),
        "AromRings":     rdMolDescriptors.CalcNumAromaticRings(mol),
        "ChiralCenters": len(Chem.FindMolChiralCenters(mol, includeUnassigned=True)),
        "HeavyAtoms":    mol.GetNumHeavyAtoms(),
    }


def _pains_brenk_clean(mol) -> bool:
    """Return True if molecule has NO PAINS or Brenk alerts."""
    params = FilterCatalogParams()
    params.AddCatalog(FilterCatalogParams.FilterCatalogs.PAINS)
    params.AddCatalog(FilterCatalogParams.FilterCatalogs.BRENK)
    catalog = FilterCatalog(params)
    return not catalog.HasMatch(mol)


# ---------------------------------------------------------------------------
# Main validator class
# ---------------------------------------------------------------------------

class Layer9FormalValidator:
    """
    Layer 9 validation gate.

    Validates a SMILES string (or a batch) against Lipinski, Veber, PAINS/Brenk,
    and a formally verified Rocq proof generated by the LLM.
    """

    def __init__(self):
        verifier = RocqVerifier()
        self.generator = RocqProofGenerator(verifier=verifier)

    def validate_molecule(self, smiles: str) -> ValidationResult:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return ValidationResult(
                smiles=smiles, valid=False,
                lipinski_ok=False, veber_ok=False,
                safety_ok=False, proof_verified=False,
                proof="", confidence=0.0,
                error_type="INVALID_SMILES", attempts=0,
            )

        desc = _compute_descriptors(mol)

        # --- heuristic pre-filters (fast, no LLM call) ---
        lipinski_ok = (
            desc["MW"] <= 500
            and desc["LogP"] <= 5
            and desc["HBD"] <= 5
            and desc["HBA"] <= 10
        )
        veber_ok = desc["RotBonds"] <= 10 and desc["PSA"] <= 140
        safety_ok = _pains_brenk_clean(mol)

        # --- formal proof via LLM + coqc ---
        proof_result: ProofResult = self.generator.generate_with_retry(
            smiles, desc, task="Prove Lipinski RO5"
        )

        checks = [lipinski_ok, veber_ok, safety_ok, proof_result.success]
        confidence = sum(checks) / len(checks)

        return ValidationResult(
            smiles=smiles,
            valid=proof_result.success and lipinski_ok and safety_ok,
            lipinski_ok=lipinski_ok,
            veber_ok=veber_ok,
            safety_ok=safety_ok,
            proof_verified=proof_result.success,
            proof=proof_result.proof,
            confidence=confidence,
            error_type=proof_result.error_type,
            attempts=proof_result.attempts,
        )

    def validate_batch(self, smiles_list: list) -> list:
        """Validate a list of SMILES strings, returning one ValidationResult each."""
        return [self.validate_molecule(s) for s in smiles_list]

    def print_report(self, result: ValidationResult) -> None:
        status = "PASS" if result.valid else "FAIL"
        print(f"\n[Layer 9 Report] {status} — {result.smiles}")
        print(f"  Lipinski RO5  : {'PASS' if result.lipinski_ok else 'FAIL'}")
        print(f"  Veber rules   : {'PASS' if result.veber_ok else 'FAIL'}")
        print(f"  Safety check  : {'PASS' if result.safety_ok else 'FAIL'}")
        print(f"  Rocq proof    : {'VERIFIED' if result.proof_verified else 'UNVERIFIED'}")
        print(f"  Confidence    : {result.confidence:.2f}")
        print(f"  LLM attempts  : {result.attempts}")
        if result.error_type:
            print(f"  Error type    : {result.error_type}")
